//go:build windows

package network

import (
	"fmt"
	"net"
	"os"
	"strings"
	"sync"

	"github.com/disembark/network/src/packet"
	"github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"golang.zx2c4.com/wireguard/tun"
	"golang.zx2c4.com/wireguard/windows/tunnel/winipcfg"
)

const windowsTunnelName = "disembark"

const wslResolvLine = "# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:"

type windowsTun struct {
	dev  *windowsDevice
	name string
	ip   string
	mtx  sync.Mutex
}

type windowsDevice struct {
	*tun.NativeTun
	name string
}

func (d *windowsDevice) Name() string {
	return d.name
}

func (d *windowsDevice) Read(buff []byte) (int, error) {
	logrus.Debug("reading into buffer")
	return d.NativeTun.Read(buff, 0)
}

func (d *windowsDevice) Write(buff []byte) (int, error) {
	logrus.Debug("writing into device")
	return d.NativeTun.Write(buff, 0)
}

func createTun() *windowsTun {
	dev, err := tun.CreateTUN(windowsTunnelName, packet.MTU)
	if err != nil {
		logrus.Fatal("failed to create tunnel: ", err)
	}

	n := &windowsTun{
		dev: &windowsDevice{
			NativeTun: dev.(*tun.NativeTun),
			name:      windowsTunnelName,
		},
		name: windowsTunnelName,
	}

	n.configTun()

	n.dev.ForceMTU(packet.MTU)
	go n.dev.RoutineTUNEventReader()

	_, err = monitorMTU(windows.AF_INET, winipcfg.LUID(n.dev.LUID()))
	if err != nil {
		logrus.Fatal("failed to create tunnel: ", err)
	}

	// we have to add a firewall rule
	if v, ok := os.LookupEnv("DISEMBARK_WINDOWS_FIREWALL"); ok && v == "1" {
		if _, err := execCmd("netsh", "advfirewall", "firewall", "show", "rule", `name="Disembark"`); err != nil {
			if _, err = execCmd("netsh", "advfirewall", "firewall", "add", "rule", `name="Disembark"`, "dir=in", "action=allow", "protocol=ANY", "remoteip=10.10.0.0/16"); err != nil {
				logrus.Warn("unable to change windows firewall: ", err)
			}
		}
	}

	return n
}

func (n *windowsTun) configTun() {
	n.mtx.Lock()
	defer n.mtx.Unlock()

	luid := winipcfg.LUID(n.dev.LUID())

	err := luid.FlushIPAddresses(windows.AF_INET)
	if err != nil {
		logrus.Fatal("failed to configure tun: ", err)
	}

	err = luid.FlushDNS(windows.AF_INET)
	if err != nil {
		logrus.Fatal("failed to configure tun: ", err)
	}

	addresses := []net.IPNet{}

	if n.ip != "" {
		ip, ipnet, _ := net.ParseCIDR(fmt.Sprintf("%s/16", n.ip))
		addresses = append(addresses, net.IPNet{
			IP:   ip,
			Mask: ipnet.Mask,
		})
	}

	ip, ipnet, _ := net.ParseCIDR("172.10.0.53/32")
	addresses = append(addresses, net.IPNet{
		IP:   ip,
		Mask: ipnet.Mask,
	})

	err = luid.SetIPAddresses(addresses)
	if err != nil {
		logrus.Fatal("failed to configure tun: ", err)
	}

	// ipv4
	if err := luid.SetDNS(windows.AF_INET, []net.IP{net.IPv4(172, 10, 0, 53)}, []string{"internal.disembark"}); err != nil {
		logrus.Fatal("failed to configure tun: ", err)
	}

	logrus.Info("configured tunnel")
}

func (d *windowsDevice) RoutineTUNEventReader() {
	logrus.Debug("Routine: event worker - started")

	for event := range d.Events() {
		if event&tun.EventMTUUpdate != 0 {
			mtu, err := d.MTU()
			if err != nil {
				logrus.Errorf("Failed to load updated MTU of device: %v", err)
				continue
			}
			if mtu < 0 {
				logrus.Errorf("MTU not updated to negative value: %v", mtu)
				continue
			}
			var tooLarge string
			if mtu > packet.MTU {
				tooLarge = fmt.Sprintf(" (too large, capped at %v)", packet.MTU)
				mtu = packet.MTU
			}
			logrus.Debugf("MTU updated: %v%s", mtu, tooLarge)
		}

		if event&tun.EventUp != 0 {
			logrus.Debug("Interface up requested")
		}

		if event&tun.EventDown != 0 {
			logrus.Debug("Interface down requested")
		}
	}

	logrus.Debug("Routine: event worker - stopped")
}

func (n *windowsTun) SetIP(ip string) {
	if n.ip != ip {
		n.ip = ip

		n.configTun()
	}
}

func (n *windowsTun) GetRaws() []Device {
	return []Device{n.dev}
}

func (n *windowsTun) GetIndex(int) Device {
	return n.dev
}

func (n *windowsTun) GetNext() Device {
	return n.dev
}

func (n *windowsTun) ConfigureDNS() (string, error) {
	proxy := ""

	if v, ok := os.LookupEnv("DISEMBARK_DNS_PROXY"); ok {
		proxy = v
	}

	if proxy != "" && !strings.Contains(proxy, ":") {
		proxy = proxy + ":53"
	}

	return proxy, nil
}

func (n *windowsTun) Name() string {
	return n.name
}

func findDefaultLUID(family winipcfg.AddressFamily, ourLUID winipcfg.LUID, lastLUID *winipcfg.LUID, lastIndex *uint32) error {
	r, err := winipcfg.GetIPForwardTable2(family)
	if err != nil {
		return err
	}
	lowestMetric := ^uint32(0)
	index := uint32(0)
	luid := winipcfg.LUID(0)
	for i := range r {
		if r[i].DestinationPrefix.PrefixLength != 0 || r[i].InterfaceLUID == ourLUID {
			continue
		}
		ifrow, err := r[i].InterfaceLUID.Interface()
		if err != nil || ifrow.OperStatus != winipcfg.IfOperStatusUp {
			continue
		}

		iface, err := r[i].InterfaceLUID.IPInterface(family)
		if err != nil {
			continue
		}

		if r[i].Metric+iface.Metric < lowestMetric {
			lowestMetric = r[i].Metric + iface.Metric
			index = r[i].InterfaceIndex
			luid = r[i].InterfaceLUID
		}
	}
	if luid == *lastLUID && index == *lastIndex {
		return nil
	}
	*lastLUID = luid
	*lastIndex = index
	return nil
}

func monitorMTU(family winipcfg.AddressFamily, ourLUID winipcfg.LUID) ([]winipcfg.ChangeCallback, error) {
	var minMTU uint32
	if family == windows.AF_INET {
		minMTU = 576
	} else if family == windows.AF_INET6 {
		minMTU = 1280
	}
	lastLUID := winipcfg.LUID(0)
	lastIndex := ^uint32(0)
	lastMTU := uint32(0)
	doIt := func() error {
		err := findDefaultLUID(family, ourLUID, &lastLUID, &lastIndex)
		if err != nil {
			return err
		}
		mtu := uint32(0)
		if lastLUID != 0 {
			iface, err := lastLUID.Interface()
			if err != nil {
				return err
			}
			if iface.MTU > 0 {
				mtu = iface.MTU
			}
		}
		if mtu > 0 && lastMTU != mtu {
			iface, err := ourLUID.IPInterface(family)
			if err != nil {
				return err
			}
			iface.NLMTU = mtu - 80
			if iface.NLMTU < minMTU {
				iface.NLMTU = minMTU
			}
			err = iface.Set()
			if err != nil {
				return err
			}
			lastMTU = mtu
		}
		return nil
	}
	err := doIt()
	if err != nil {
		return nil, err
	}
	cbr, err := winipcfg.RegisterRouteChangeCallback(func(notificationType winipcfg.MibNotificationType, route *winipcfg.MibIPforwardRow2) {
		if route != nil && route.DestinationPrefix.PrefixLength == 0 {
			doIt()
		}
	})
	if err != nil {
		return nil, err
	}
	cbi, err := winipcfg.RegisterInterfaceChangeCallback(func(notificationType winipcfg.MibNotificationType, iface *winipcfg.MibIPInterfaceRow) {
		if notificationType == winipcfg.MibParameterNotification {
			doIt()
		}
	})
	if err != nil {
		cbr.Unregister()
		return nil, err
	}
	return []winipcfg.ChangeCallback{cbr, cbi}, nil
}
